%% Thesis Template of Chinese Academy of Sciences
%%   for using CASthesis package with LaTeX2e
%%
%% Created by Ling-Yun Wu <aloft@ctex.org>
%%
%% $Id: template.tex,v 1.10 2007/01/09 05:10:46 aloft Exp $

%\documentclass[dvipdfm]{CASthesis}
\documentclass[pdftex]{CASthesis}
% 可选参数：
% notypeinfo 取消扉页的LaTeX版本信息
%
% 下面三个选一个：
% dvipdfm 使用 dvipdfm(x) 生成最终的 PDF 文档 (缺省设置）
% dvips 使用 dvips 生成最终的 PS 文档
% pdftex 使用 pdfLaTeX 生成最终的 PDF 文档

%image
\usepackage{graphicx}

%%%算法伪代码包开始，烦人的包！
\usepackage{algorithm}
\usepackage{algorithmicx}
\usepackage[noend]{algpseudocode}
\usepackage{amsmath}
\usepackage[top=2cm, bottom=2cm, left=2cm, right=2cm]{geometry}
%%%基本命令
%\State
%\If{}  \EndIf
%\If{}  \Else  \EndIf
%\If{}  \ElsIf{}   \Else  \EndIf
%\For{}  \EndFor
%\ForAll{}  \EndFor
%\While{}  \EndWhile
%\Repeat  \Until{}
%\Loop  \EndLoop
%\Require
%\Ensure
%\Function{}{}
%\EndFunction
%\State \Return
%\Comment{}

%%%%%%%%%%%%% 代码块设置
\usepackage{listings}
\usepackage{color}
\usepackage{xcolor}
\definecolor{keywordcolor}{rgb}{0.8,0.1,0.5}

\lstset{breaklines}%这条命令可以让LaTeX自动将长的代码行换行排版
\lstset{extendedchars=false}%这一条命令可以解决代码跨页时，章节标题，页眉等汉字不显示的问题
\lstset{backgroundcolor=\color{lightgray}}

\lstset{
    language=C++, %用于设置语言为C++
	keywordstyle=\color{keywordcolor} \bfseries,
	identifierstyle=,
	basicstyle=\ttfamily,
	commentstyle=\color{blue} \textit,
	stringstyle=\ttfamily,
	showstringspaces=false,
	frame=shadowbox, %边框
	captionpos=b
}
%%%%%%%%%%%%% 代码块设置

% 设置图形文件的搜索路径
\graphicspath{{chapter/}{figures/}{.}}

% 取消链接的颜色（黑白打印时）
%\hypersetup{colorlinks=false}

% 小节标题靠左对齐
%\CTEXsetup[format+={\flushleft}]{section}

\usepackage{color}
\usepackage{enumerate}
\definecolor{BLUE}{rgb}{0,0,1}
\newcommand{\KEYWORD}[1]{\textbf{\color{BLUE}{#1}}}

\begin{document}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% 封面部分
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  % 中文封面内容

  \serialnumber{xxx}
  \title{IB网络数据接收发模块}
  \author{李程鹏}
  \institute{四川大学计算机学院}


  % 封面
  \maketitle



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% 前言部分
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\frontmatter

 %  摘要
 % \include{chapter/abstract}

  % 目录
  %\tableofcontents
  % 表格目录
 % \listoftables
  % 插图目录
%  \listoffigures


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% 正文部分
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\mainmatter

\chapter{算法实现}
\section{IB网络数据接收发模块简介}
IB网络数据接收发模型和B/S（Browser/Server）模型很类似。在B/S模型中浏览器通过网址向服务器请求网站数据，服务器收到请求后会向浏览器传输所需网站内容。当然上述过程隐藏了很多B/S模型的实现细节，在这里不做详细讨论。IB网络数据接收发模型的网络节点之间的数据交换过程也会有同样的请求流程，但是与B/S 模型有很大不同的是任意一个IB节点既可以是浏览器也可以是服务器，便于节点间的数据交换。

IB网络数据接收发模块主要分为两个功能块：
\begin{itemize}
    \item[\textbf{*}]\textbf{IBDataRequestPacket模块：}IBDataRequestPacket（IB数据请求包）是一个网络数据包，用于IB节点向其他IB节点发送数据请求操作。该包包含了一些IB 数据请求的必要内容，比如：应该使用那块Queue Pair去操作IB数据，所需准备的缓冲区大小和请求什么类型的数据等。
    \item[\textbf{*}]\textbf{IBWCEHandlingTheread模块：}该模块是一个IB 网络监听线程，用于监听IB节点的数据收发状态操作。
\end{itemize}

假设当前有两台IB主机：数据请求端A和数据发送端B。数据请求端A为了获取资源R，首先会向数据发送端B发送数据请求包（IBDataRequestPacket）请求资源R，同时数据请求端A会准备好用于数据操作的Queue Pair；当数据发送端B收到数据请求端A的数据请求包，它会根据数据请求包的Queue Pair直接向数据请求端发送其所需的数据R。但需要注意的是，IB数据请求包是通过TCP或UDP 的方式发送到数据发送端B，真正使用IB数据传输的过程是数据发送端B向数据接收端A传输资源R的时候。IB 网络数据接收发操作流程如图1.1。
\begin{figure}
\centering
\includegraphics{IBRequest.jpg}
\caption{IB网络数据接收发操作}
\label{figc1}
\end{figure}

\section{IBDataRequestPacket模块}
\subsection{IBDataRequestPacket包内容}
在表1.1中，IBDataRequestPacket包除了包含一些基本的信息外，还包含了包的额外的信息，表示IB节点所请求的数据类型：文件数据和消息数据。
\begin{table} \caption {资源请求包的额外信息}
\centering
\begin{tabular}{|c|c|}
\hline SenderNodeName&包发送IB节点名\\
\hline ReceiverNodeName&包接收IB节点名\\
\hline RecvBufferSize&接收数据的缓存大小\\
\hline ReceiverQueuePairID&接收数据的ID\\
\hline PacketExtraInfo&包的额外信息\\
\hline
\end{tabular}
\end{table}

\subsection{IBDataRequestPacket包处理}
IB数据发送端在接收到IB数据请求端的IBDataRequestPacket过后，需要对包进行相应的一些列处理，处理流程如下：
\begin{enumerate}
  \item 在整个网络系统中获取IB节点间的网络连接
  \item 准备IB数据请求端所请求的数据
  \item 通过网络连接向IB数据请求端发送数据
\end{enumerate}

IBDataRequestPacket包处理算法伪码如Algorithm1。伪码的符号说明如下：\\
\indent (1)	HostNode：当前主机的网络节点（IB、UDP）信息\\
\indent (2)	Connection：当前主机之间的连接信息\\
\indent (3)	DataRequested：所请求的数据
\begin{algorithm}
   \caption{processV}
   \begin{algorithmic}[1]
      \Require $HostNode$
      \Ensure $ $
      \Function {processV}{$HostNode$}
          \State $Connection \gets findConnection2Receiver(HostNode,IP,NodeName)$
          \State $DataRequested \gets prepareIBData()$
          \State $sendRawBuffer(DataRequested,ID) \gets Connection$
      \EndFunction
   \end{algorithmic}
\end{algorithm}

IB数据准备工作涉及到两种类型：文件数据和消息数据，因此IBDataRequestPacket模块在处理数据过程中会有不同的数据准备方式。Algorithm2描述了整体的数据准备工作。
\begin{algorithm}
   \caption{prepareIBData}
   \begin{algorithmic}[1]
      \Require $ $
      \Ensure $DataRequested$
      \Function {prepareIBData}{$ $}
          \If {$PacketExtraInfo\ \textbf{is}\ PacketExtraInfoOnMessage$}
              \State \Return{$prepareIBMessageData(PacketExtraInfo)$}
          \Else
              \State \Return{$prepareIBFileData(PacketExtraInfo)$}
          \EndIf
      \EndFunction
   \end{algorithmic}
\end{algorithm}

\subsection{IBDataRequestPacket数据接收准备}
IB数据请求端在发送IBDataRequestPacket前，需要对IB网络底层进行数据的接收准备操作，根据指定的QueuePair ID来配置相关Queue Pair。其具体操作过程请参照IBConnection 和QueuePair模块。

\section{IBWCEHandlingTheread模块}
IBWCEHandlingTheread模块是一个独立的线程，负责处理IB网络节点间的数据发送与接收状态工作。

\subsection{IBWCEHandlingTheread主功能}
IBWCEHandlingTheread实现主功能迭代过程中，会不断调用ib\_poll\_cq函数（IB 底层函数）是网络来检查在completion queue里面是否有新的work reuqests 请求，并返回当前completion queue状态。IBWCEHandlingTheread 模块主要使用其中的两种状态：
\begin{itemize}
    \item[\textbf{*}]\textbf{IB\_NOT\_FOUND：}当前在completion queue中没有新的work requests请求被取出。
    \item[\textbf{*}]\textbf{IB\_SUCCESS：}当前在completion queue中有新的work requests请求被取出。
\end{itemize}
ib\_poll\_cq同时会获取Work Completion的信息，如果Work Completion的类型是IB\_WC\_SEND表示当前需要进行发送数据操作，如果是IB\_WC\_RECV 类型则进行数据接收操作。算法的伪码如Algorithm3：
\begin{algorithm}
   \caption{runV}
   \begin{algorithmic}[1]
      \Require $ $
      \Ensure $ $
      \Function {runV}{$ $}
         \While{$ThreadIsRunning()$}
            \While{$true$}
                \State $IBState \gets ib\_poll\_cq(CompletionQueue)$
                \State $SucceededRequest \gets ib\_poll\_cq(CompletionQueue)$
                \If {$IBState \textbf{=} IB\_NOT\_FOUND$}
                    \State $break$
                \ElsIf {$IBState \textbf{=} IB\_SUCCESS$}

                    \State $MemoryBlock \gets fetchMemoryBlock(SucceededRequest)$
                    \If {$SucceededRequest \textbf{=} IB\_WC\_SEND$}
                        \State $sendData(MemoryBlock)$
                    \ElsIf {$SucceededRequest \textbf{=} IB\_WC\_RECV$}
                        \State $receiveData(MemoryBlock)$
                    \EndIf
                \EndIf
             \EndWhile
         \EndWhile
      \EndFunction
   \end{algorithmic}
\end{algorithm}

\subsection{IBWCEHandlingTheread发送数据}
IB发送数据的流程是在其他功能块完成的，当其他功能块发送完成IB数据，会触发IB 的信号从而通知IBWCEHandlingTheread，IBWCEHandlingTheread再数据一条日志语句“Success to send data with IB node”。

\subsection{IBWCEHandlingTheread接收数据}
IBWCEHandlingTheread收到文件接收的信号时会进行数据接收的相关工作。在数据接收的流程中，首先会取出MemoryBlock中的缓存数据，根据当前接收的数据类型分别进行文件的存储或者消息的处理。处理文件数据会先在包的额外信息（CPacketExtraInfoOnFile）中取出文件所需保存的路径，然后直接将缓冲区的文件数据存储到上述路径中；处理消息数据时，首先会通过字符串流保存缓冲区的内容，然后再逆序列化出字符串流中的基础包类（CPacket），最后调用包的处理函数。Algorithm4是IBWCEHandlingTheread接收数据伪码表示：
\begin{algorithm}
   \caption{receiveData}
   \begin{algorithmic}[1]
      \Require $WorkCompletion, MemoryBlock$
      \Ensure $ $
      \Function {receiveData}{$WorkCompletion, MemoryBlock$}
          \State $pBuffer \gets MemoryBlock$
          \If {$PacketExtraInfo\ \textbf{is}\ PacketExtraInfoOnMessage$}
              \State $DeserializedStream \gets pBuffer$
              \State $Packet \gets Deserialize(DeserializedStream)$
              \State $processV(Packet) $
          \Else
              \State $FilePath \gets PacketExtraInfo$
              \State $ofstream \gets OutputFile(FilePath)$
              \State $write(pBuffer) $
          \EndIf
      \EndFunction
   \end{algorithmic}
\end{algorithm}

\end{document}
